////////////////////////////////////////////////////////////////////////////////
//
//    Copyright (c) 2022 - 2023.
//    Haixing Hu, Qubit Co. Ltd.
//
//    All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////
package ltd.qubit.commons.id;

import javax.annotation.concurrent.Immutable;

import ltd.qubit.commons.lang.Equality;
import ltd.qubit.commons.lang.Hash;
import ltd.qubit.commons.text.tostring.ToStringBuilder;

import static ltd.qubit.commons.lang.Argument.requireInCloseRange;
import static ltd.qubit.commons.lang.Argument.requireNonNull;
import static ltd.qubit.commons.math.LongBit.reverse;

/**
 * ID构造器。
 *
 * <p>一个完整的ID按照以下模式构造：
 * <pre><code>
 *  [生成模式] [时间戳] [时间戳精度] [主机编号] [序列号]
 * </code></pre>
 * 其中，
 * <ul>
 * <li>生成模式：为顺序模式或稀疏模式，占据1个bit；当生成模式为顺序模式时，时间戳的bit按照正序
 * 排列，从而使得连续生成的序列号连续分布；当生成模式为稀疏模式时，时间戳的bit按照反序排列，从而
 * 使得连续生成的序列号分散开；</li>
 * <li>时间戳：时间戳精度为秒时，占据31个bit，最多可表示68年；
 * 时间戳精度为毫秒时，占据41个bit，最多可表示69年；</li>
 * <li>时间戳精度：为秒或毫秒，占据1个bit；</li>
 * <li>主机编号：占据9个bit，最多允许2^9=512个不同取值；</li>
 * <li>序列号：在该时间戳范围内的递增序列号；时间戳精度为秒时，
 * 占据22个bit，最多可表示419万个不同的序列号；
 * 时间戳精度为毫秒时，占据12个bit，最多可表示4096个不同的序列号；</li>
 * </ul>
 *
 * @author 胡海星
 */
@Immutable
public class IdBuilder implements Constant {

  /**
   * ID的生成模式，占据一个bit。
   */
  private final Mode mode;

  /**
   * 生成模式比特向左位移位数。
   */
  private final transient int modeShift;

  /**
   * 时间戳的精度。
   */
  private final Precision precision;

  /**
   * 时间戳精度比特向左位移位数。
   */
  private final transient int precisionShift;

  /**
   * 主机编号。
   */
  private final long host;

  /**
   * 主机编号比特向左位移位数。
   */
  private final transient int hostShift;

  /**
   * 时间戳占据的bit数目。
   */
  private final transient int timestampBits;

  /**
   * 时间戳比特向左位移位数。
   */
  private final transient int timestampShift;

  /**
   * 最大可允许时间戳。
   */
  private final transient long maxTimestamp;

  /**
   * 最大可允许序列号。
   */
  private final transient long maxSequence;

  /**
   * 预先计算出的在最终ID中不变的数据。
   */
  private final transient long fixedData;

  public IdBuilder(final Mode mode, final Precision precision, final long host) {
    this.mode = requireNonNull("mode", mode);
    this.precision = requireNonNull("precision", precision);
    this.host = requireInCloseRange("host", host, HOST_MIN, HOST_MAX);
    this.timestampBits = precision.getTimestampBits();
    this.maxTimestamp = (1L << timestampBits) - 1L;
    final int sequenceBits = precision.getSequenceBits();
    this.maxSequence = (1L << sequenceBits) - 1L;
    // ID = [mode] [timestamp] [precision] [host] [sequence]
    modeShift = timestampBits + PRECISION_BITS + HOST_BITS + sequenceBits;
    timestampShift = PRECISION_BITS + HOST_BITS + sequenceBits;
    precisionShift = HOST_BITS + sequenceBits;
    hostShift = sequenceBits;
    fixedData = (((long) mode.ordinal()) << modeShift)
        | (((long) precision.ordinal()) << precisionShift)
        | (host << hostShift);
  }

  public final Mode getMode() {
    return mode;
  }

  public final Precision getPrecision() {
    return precision;
  }

  public final long getHost() {
    return host;
  }

  public final long getMaxTimestamp() {
    return maxTimestamp;
  }

  public final long getMaxSequence() {
    return maxSequence;
  }

  /**
   * 构造一个ID。
   *
   * <p>一个完整的ID按照以下模式构造：
   * <pre><code>
   *  [生成模式] [时间戳] [时间戳精度] [主机编号] [序列号]
   * </code></pre>
   * 其中，
   * <ul>
   * <li>生成模式：为稀疏模式或顺序模式，占据1个bit；当生成模式为稀疏模式时，
   * 时间戳的bit按照反序排列，从而使得连续生成的序列号分散开；当生成模式为
   * 顺序模式时，时间戳的bit按照正序排列，从而使得连续生成的序列号连续分布；</li>
   * <li>时间戳：时间戳精度为秒时，占据31个bit，最多可表示68年；
   * 时间戳精度为毫秒时，占据41个bit，最多可表示69年；</li>
   * <li>时间戳精度：为秒或毫秒，占据1个bit；</li>
   * <li>主机编号：占据9个bit，最多允许2^9=512个不同取值；</li>
   * <li>序列号：在该时间戳范围内的递增序列号；时间戳精度为秒时，
   * 占据22个bit，最多可表示419万个不同的序列号；
   * 时间戳精度为毫秒时，占据12个bit，最多可表示4096个不同的序列号；</li>
   * </ul>
   *
   * @param timestamp
   *     当前时间戳，根据指定的精度从指定的起点开始算起
   * @param sequence
   *     当前序列号，在同一个时间戳精度内序列号递增不重复
   * @return 构造的ID
   */
  public final long build(final long timestamp, final long sequence) {
    //    timestamp &= maxTimestamp;        // 防止timestamp越界
    //    sequence  &= maxSequence;         // 防止sequence越界
    assert (timestamp <= maxTimestamp);
    assert (sequence <= maxSequence);
    final long t = (mode == Mode.SEQUENTIAL
              ? timestamp
              : (reverse(timestamp) >>> (Long.SIZE - timestampBits)));
    // ID = [timestamp] [mode] [precision] [host] [sequence]
    return ((t << timestampShift) | fixedData | sequence);
  }

  /**
   * Extracts the mode from an ID generated by this builder.
   *
   * @param id
   *     an ID generated by this builder.
   * @return the mode in the specified ID.
   */
  public final Mode extractMode(final long id) {
    final int m = (int) ((id >>> modeShift) & ((1L << MODE_BITS) - 1));
    if (m < 0 || m > Mode.values().length) {
      throw new IllegalArgumentException("Invalid mode in the generated ID.");
    }
    return Mode.values()[m];
  }

  /**
   * Extracts the timestamp from an ID generated by this builder.
   *
   * @param id
   *     an ID generated by this builder.
   * @return the timestamp in the specified ID.
   */
  public final long extractTimestamp(final long id) {
    final long timestamp = ((id >>> timestampShift) & maxTimestamp);
    if (mode == Mode.SEQUENTIAL) {
      return timestamp;
    } else {
      return (reverse(timestamp) >>> (Long.SIZE - timestampBits));
    }
  }

  /**
   * Extracts the precision from an ID generated by this builder.
   *
   * @param id
   *     an ID generated by this builder.
   * @return the precision in the specified ID.
   */
  public final Precision extractPrecision(final long id) {
    final int p = (int) ((id >>> precisionShift) & ((1 << PRECISION_BITS) - 1));
    if (p < 0 || p > Precision.values().length) {
      throw new IllegalArgumentException("Invalid precision in the generated ID.");
    }
    return Precision.values()[p];
  }

  /**
   * Extracts the host from an ID generated by this builder.
   *
   * @param id
   *     an ID generated by this builder.
   * @return the host in the specified Id.
   */
  public final long extractHost(final long id) {
    return ((id >>> hostShift) & ((1 << HOST_BITS) - 1));
  }

  /**
   * Extracts the sequence from an ID generated by this builder.
   *
   * @param id
   *     an ID generated by this builder.
   * @return the sequence in the specified Id.
   */
  public final long extractSequence(final long id) {
    return (id & maxSequence);
  }

  @Override
  public boolean equals(final Object o) {
    if (this == o) {
      return true;
    }
    if ((o == null) || (getClass() != o.getClass())) {
      return false;
    }
    final IdBuilder other = (IdBuilder) o;
    return Equality.equals(host, other.host)
        && Equality.equals(mode, other.mode)
        && Equality.equals(precision, other.precision);
  }

  @Override
  public int hashCode() {
    final int multiplier = 7;
    int result = 3;
    result = Hash.combine(result, multiplier, mode);
    result = Hash.combine(result, multiplier, precision);
    result = Hash.combine(result, multiplier, host);
    return result;
  }

  @Override
  public String toString() {
    return new ToStringBuilder(this)
        .append("mode", mode)
        .append("precision", precision)
        .append("host", host)
        .toString();
  }
}
